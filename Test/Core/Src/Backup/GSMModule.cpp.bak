/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     02/11/2024 18:42:21
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "GSMModule.hpp"
extern "C"{
	#include "usart.h"
	#include "usb.h"
}
#include <cstring>
#include <iostream>
#include <string>

const char* MSG = "AT+CMGS=";
const char* MSG_TEXT_MODE_ = "AT+CMGF=1\r\n";
char END_OF_MSG = 0x1A;

const char* CALL = "ATD+";

const char* AT = "AT\r\n";


static GSM_Module* gsm = nullptr;


GSM_Module::GSM_Module(const Parameters& parameters){
	gsm = this;
	this->parameters = parameters;
	if(!send_at_command(AT) || !send_at_command(MSG_TEXT_MODE_)){
		Error_Handler();
	}
	start_receiving();
}

void GSM_Module::make_call(const char* number){
	if (this->current_state != IDLE) {
	    return;
	}

	char command[32];
	snprintf(command, sizeof(command), "%s%s\r\n", CALL, number);
	transmit(command, strlen(command));

	this->prev_state = this->current_state;
	this->current_state = this->CALLING;
}

void GSM_Module::receive_call() {
	transmit("ATA\r\n", 5);
}

void GSM_Module::hang_up(){
	if (this->current_state != CALLING) {
	    return;
	}

	transmit("ATH\r\n", 5);
	this->current_state = this->prev_state;
	this->prev_state = IDLE;
}

bool GSM_Module::send_at_command(const char* command){
	if (!transmit(command, strlen(command))){
		return false;
	}
	char answer[256];
	bool result = receive(answer, 100);
	if (result != HAL_OK or !strstr(answer, "OK")){
		return false;
	}
	return true;
}

void GSM_Module::handle_interruption(){

	std::string buffer_to_str(reinterpret_cast<char*>(rx_buffer), rx_index);

    if (buffer_to_str.find("RING")) {

    	this->prev_state = this->current_state;
    	this->current_state = RINGING;

    	receive_call();

    } else if (buffer_to_str.find("+CTM:")) {

//    	receive_sms();

    } else {

    	this->prev_state = this->current_state;
    	this->current_state = this->UNKNOWN;

    }
//    std::memset(rx_buffer, 0, sizeof(rx_buffer));
    rx_index = 0;
}

extern "C" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
	if (gsm && huart == gsm->parameters.uart_handle){

        if (gsm->rx_buffer[gsm->rx_index] == '\n'){
        	gsm->handle_interruption();
        }

        gsm->rx_index = (gsm->rx_index + 1) % 256;

        gsm->start_receiving();
	}
}

void GSM_Module::send_sms(const char* number, const char* message){
	char command[32];
	snprintf(command, sizeof(command), "%s\"%s\"\r", MSG, number);
	transmit(command, strlen(command));
	HAL_Delay(1000);
    transmit(message, strlen(message));
    transmit(&END_OF_MSG, 1);
    HAL_Delay(1000);
}

Parameters load_parameters(){
	Parameters parameters;
	parameters.uart_handle = &huart2;
	parameters.rx_pin = USART_RX_Pin;
	parameters.rx_port = USART_RX_GPIO_Port;
	parameters.tx_pin = USART_TX_Pin;
	parameters.tx_port = USART_TX_GPIO_Port;
	return parameters;
}

void GSM_Module::start_receiving() {
    HAL_UART_Receive_IT(parameters.uart_handle, &rx_buffer[rx_index], 1);
}

bool GSM_Module::transmit(const char* data, size_t size) {
    return HAL_UART_Transmit(parameters.uart_handle, (uint8_t*)data, size, 100) == HAL_OK;
}

bool GSM_Module::receive(char* buffer, size_t size) {
    return HAL_UART_Receive(parameters.uart_handle, (uint8_t*)buffer, size, 100) == HAL_OK;
}



