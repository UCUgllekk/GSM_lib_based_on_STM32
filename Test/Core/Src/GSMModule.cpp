/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     02/11/2024 18:42:21
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "GSMModule.hpp"
#include "usart.h"
#include "usb.h"
#include <cstring>
#include <iostream>
#include <string>

const char* MSG = "AT+CMGS=";
const char* MSG_MODE_1 = "AT+CMGF=1\r\n";
const char* MSG_MODE_0 = "AT+CMGF=0\r\n";

const char* CALL = "ATD+";

const char* AT = "AT\r\n";

GSM_Module* self = nullptr;

GSM_Module::GSM_Module(const Parameters& parameters){
	self = this;
	this->parameters = parameters;
//	if (!send_at_command(AT)){
//		throw std::runtime_error("GSM not initialized correctly!");
//	}
	HAL_UART_Receive_IT(this->parameters.uart_handle, rx_buffer, sizeof(rx_buffer));
}

//int GSM_Module::send_sms(const char* message){
//	return 0;
//}

void GSM_Module::make_call(const char* number){
	// make call
	char command[32];
	snprintf(command, sizeof(command), "%s%s\r\n", CALL, number);
	HAL_UART_Transmit(this->parameters.uart_handle, (uint8_t*)command, strlen(command), 100);
}

void GSM_Module::receive_call() {
	char command[32];
	int index = 0;

	while (true) {
		uint8_t received_char;

		HAL_UART_Receive(this->parameters.uart_handle, &received_char, 1, 100);

		if (received_char) {
			command[index] = received_char;

			index++;

			std::string result = command;

			if (result.find("RING") <= sizeof(command) - 1) {
				HAL_UART_Transmit(this->parameters.uart_handle, (uint8_t*)"ATA\r\n", 5, 100);
			}
		}

		if (index >= sizeof(command) - 1) {
			memset(command, 0, sizeof(command));
			index = 0;
		}
	}

}

void GSM_Module::hang_up(){
	HAL_UART_Transmit(this->parameters.uart_handle, (uint8_t*)"ATH\r\n", 5, 100);
}


//bool GSM_Module::send_AT(){
//	// private send "AT" command, return true if accepted good, return false if otherwise
//	const char* check = "AT\r\n";
//	if (HAL_UART_Transmit(this->parameters.uart_handle, (uint8_t*)check, strlen(check), 10) != HAL_OK){
//		return false;
//	}
//	char answer[10];
//	HAL_StatusTypeDef result = HAL_UART_Receive(this->parameters.uart_handle, (uint8_t*)answer, 10, 10);
//	if (result == HAL_OK) {
//		if (strstr(answer, "OK")){
//			return true;
//		}
//	}
//	return false;
//}

bool GSM_Module::send_at_command(const char* command, int retries){
	if (retries <= 0){
		return false;
	}
	if (HAL_UART_Transmit(this->parameters.uart_handle, (uint8_t*)command, strlen(command), 100) != HAL_OK){
		return false;
	}
	char answer[256];
	HAL_StatusTypeDef result = HAL_UART_Receive(this->parameters.uart_handle, (uint8_t*)answer, sizeof(answer), 100);
	if (result == HAL_OK) {
		if (!strstr(answer, "OK")){
			return send_at_command(command, retries-1);
		}
	}
	return true;
}

//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
//	if (huart == &huart2){
//		char* buffer = (char*)self->rx_buffer;
//
//		if(strstr(buffer, "CALL")){
//
//		}
//		else if(strstr(buffer, "+CMTI:")){
//			int index = 0;
//			sscanf(buffer, "+CMTI: \"SM\",%d", &index);
//			read_sms(index);
//		}
//	}
//}

void GSM_Module::send_sms(const char* number, const char* message){

	send_at_command(MSG_MODE_1);
	HAL_Delay(1000);

	char command[32];
	snprintf(command, sizeof(command), "%s\"+%s\"", MSG, number);
	send_at_command(command);
	HAL_Delay(1000);

	char msg[256];

    snprintf(msg, sizeof(msg), "%s\r\n0x1A", message);
    send_at_command(msg);

    send_at_command(MSG_MODE_0);
}

Parameters load_parameters(){
	Parameters parameters;
	parameters.uart_handle = &huart2;
	parameters.rx_pin = USART_RX_Pin;
	parameters.rx_port = USART_RX_GPIO_Port;
	parameters.tx_pin = USART_TX_Pin;
	parameters.tx_port = USART_TX_GPIO_Port;
	return parameters;
}
